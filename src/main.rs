use bytes::Buf;
use std::error::Error;
use std::fs::{self, File};
use std::io::copy;
use filesize::PathExt;
use std::path::{Path, PathBuf};

struct Document {
    name: PathBuf,
    content: String,
}

fn main() {
    println!("Welcome to the sussy malware ඞ \n");
    println!("ඞ ඞ ඞ ඞ ඞ ඞ ඞ ඞ ඞ \n>Please wait, making this folder sus....");

    // match download_sus_imges() {
    //     Ok(()) => (println!(">Downloaded really sus images")),
    //     _ => {
    //         println!("Something is sus with your network, proceeding without downloading files.")
    //     }
    // }

    match collect_and_spam_files() {
        Ok(()) => (),
        _ => (println!("Something went wrong")),
    }
}

fn download_sus_imges() -> Result<(), Box<dyn Error>> {
    let images: Vec<&str> = vec![
        "https://i.redd.it/sqt01fync8381.jpg",
        "https://i.redd.it/oup944dz5mw51.jpg",
        "https://i.redd.it/zxynz9sgtgu51.jpg",
    ];

    let mut i = 0i32;
    for url in images {
        i = i + 1;
        let filename = format!("{}-{}", i.to_string(), "sus.jpg");
        let mut file = File::create(filename)?;
        let mut content = reqwest::blocking::get(url)?.bytes()?.reader();
        copy(&mut content, &mut file)?;
    }
    Ok(())
}

fn collect_and_spam_files() -> Result<(), Box<dyn Error>> {
    let mut documents: Vec<PathBuf> = vec![];
    for entry in fs::read_dir(".")? {
        let _path_buf = entry?.path();
        let path = Path::new(&_path_buf);
        let ext = path.extension();
        if path.is_file() {
            let size = path.size_on_disk()?;
            if size < 800000 {
                if ext == None {
                    documents.push(_path_buf);
                } else if ext.unwrap() != "jpg" {
                    documents.push(_path_buf)
                }
            }
        }
    }
    println!("{:?}", documents);
    Ok(())
}
