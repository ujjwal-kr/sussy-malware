# The HackArmour Malware Challenge Writeup

The zip contains malware executable and a readme.txt with some instructions. The malware will only affect the `affected_folder` so dont take it out of that directory. Let's run it:

![malware test run](./test.png)

Now if you open the txt files, any information which was present there wont be found and rather they are spammed by some "sus" text. Do not close the terminal or the program. If you try to give any flag, it will ask you infinitely until you supply the correct one hence we have unlimited chances.

Let's open the binary in ghidra and keep the analysis settings to default. It will take some time to analyze it has the binary is big. Let's take a look at the functions list:

![functions](./functions.png)

## Finding the actual `main`
The main function is where the program starts but as this malware is written in rust, we will have to dig deeper to find the actual implemented code. Let's look at the disassembly of `entry` as that is what runs first this time.

![entry](./entryFunc.png)

After checking all the functions it calls, I could identify that the third function `FUN_0016ab20` has a call to another function. Lets look at the disassembly of this func:

![main_call](./main_call.png)

This function makes a call to `FUN_00168940`. This function is the main function. We can say that as when we scroll down the disassembly, we can see some urls pointing to reddit. These are the urls of the images that the malware just fethed.

![reddit_img](./reddit.png)

## Reversing `main`
While looking at the source code, we can find lots of strings used in the program before. This confirms that we might be at the right place. Here is an example of such string:

![string](string.png)

We can also find some text used in the program and even some potentially useful urls. But lets move on as they kinda seem not to work due to poor placement. After searching more strings in the program, we can see a string called `Correct Flag`. Lets see what triggered that call.

![!ask_flag_call](ask_flag_call.png)

The function `FUN_0016a6d0` runs before calling the "Correct flag" string. There may be some sort of input and some checks for the supplied flag. Lets get into the decompilation of that func:

![pastebin_url](pastebin_url.png)

Now let's look at the value of `local_210` and `local_200`.

`local_210` has eight characters at the front and after that we have `https://paste`.

`local_200` starts with "bin.com/raw/" and another paste url.

We also have some `CONCAT88()` call to `local_210` which combines the string with something or makes it combinable to another string. So if we combine `local_210` and `local_200`, we get something like "https://pastebin.com/raw" (from the end of `local_210`). Pastebin is a service to host text. We can find our flag there. 

If we go further in the url, we will see a string `9cDvNGa1eeVXATq0`. No pastebin exists for this id. If you research on the id format of pastebin, at the time of writing this it uses eight characters for an id. Also, the text present at the beginning of `local_210` is identical to the last 8 chars of the strings we found in `local_200` After figuring this out, we finally have two ids: `9cDvNGa1` and `eeVXATq0`.

The first ID has a sus ascii and the second one has this:

![flag](./flag.png)

This text is clearly resersed and you can reverse the function which reverses it. Now if we input the unreversed string, we get `flag{un5us5_tH3m}`. After submitting that in the prompt, all the files will be restored. 

Thanks for making it so far, do star this repo if you liked this project.

 
